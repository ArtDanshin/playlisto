# Архитектура фронтенда приложения Playlisto

## Обзор архитектуры

Проект использует Domain-Driven Design (DDD) подход с Zustand для управления состоянием. Архитектура разделена на четкие слои и домены для лучшей масштабируемости и поддерживаемости.

Для хранения данных о пользовательских плейлистах используется IndexedDB. Это обеспечивает независимость от инфраструктур, сохранность данных пользователи и полную обособленность приложения. Любой может развернуть приложения у себя и начать его использовать

Есть в таком подходе и недостатки - для работы с API нужно заводить свои API ключи

## Структура проекта

```
src/
├── domains/             # Функциональные домены
│   ├── playlists/       # Управление плейлистами
│   │   ├── components/  # UI компоненты домена
│   │   └── store/       # Zustand store
│   └── spotify/         # Интеграция со Spotify
│       ├── components/  # UI компоненты домена
│       └── store/       # Zustand store
├── infrastructure/      # Инфраструктурный слой
│   ├── api/             # Интерфейсы/функции для работы с API
│   ├── configs/         # Конфигурация
│   ├── services/        # Адаптеры для работы с источниками данных
│   └── storage/         # Интерфейсы/функции для работы с базами данных
├── layout/              # Компоненты определяющие вид и компоновку общих частей приложения
├── pages/               # Описание компоновки страниц относительно активного маршрута приложения
├── shared/              # Общие ресурсы
│   ├── components/      # Переиспользуемые UI компоненты
|   |   ├── ...          # Компоненты собранные для приложения
|   |   └── ui           # Компоненты импортированные из библиотеки компоннетов shadcn
│   ├── hooks/           # Общие React хуки
│   ├── types/           # Общие типы
│   └── utils/           # Утилиты
├── App.tsx            
├── main.tsx             
└── providers.tsx        # Инициализация всех общих провайдеров хранилищ      
```

## Основные атомарные его единицы

### Компонент

Компонент, написанный на React

Правила для организации работы с компонентами:
- В компоненте не должно присутствовать много логики для работы с данными. Для этого есть слои `services` и `store`
- Если есть общие части верстки - лучше вынести либо в дочерний компонент, либо в слой `shared/components`
- У каждого компонента должен быть `_story_` файл, в котором описан по крайней мере один кейс его использования

Структура:
```
Component/                 # Папка с компонентом
├── index.tsx              # Экспорт компонента и его частей
├── Component._story_.tsx  # Описание его работы в Storybook формате
├── Component.tsx          # Основной компонент
└── ComponentChild.tsx     # Если у компонента есть свои специфичные повторяющиеся части, можно вынести в дочерний компонент
```

### Store

Хранилища информации хранящейся в приложении в данный момент времени, а так же методов работы с ней. Например трансформация для правильного отображения в UI или перед отправкой в более общий слой сервиса

Чтобы приложения было проще тестировать, в папке также создается `mock` файл, содержащий функции заглушки. Продовый store может содержать данные зависящие от внешних источник. Mock store не зависит от внешних источников, потому может использоваться для тестов

Структура:
```
store/                   # Папка со store'ом
├── index.tsx            # Инициализация store в зависимости от окружения
├── store.mock.tsx       # Store для тестирования, где все методы - заглушки, возвращающие тестовые данные
└── store.tsx            # Основной Store, где описана вся логика
```

## Домены

Изолированные(или в основном изолированные) части приложения на основании бизнес логики

Например, существующие в данный момент домены:

- `fileSource` - Логика специфичная для работы с данными из источников файлов
- `playlist` - Логика для работы с плейлистами и треками непосредственно приложения
- `spotifySource` - Логика специфичная для работы с данными из Spotify файлов

Только в `playlist` домене есть импорт компонентов из `*Source` доменов. Остальные домены не могут обращаться к друг другу

Внутри домена может быть структура вида:
```
exampleDomain/
├── components/     # Папка с компонентами домена
└── store/          # Store с бизнес логикой компонента
```

В наименовании компонентов домена лучше избегать повторного наименования домена. Это нормально, что есть компоненты с одинаковыми именами в разных слоях

## Инфраструктурный слой

### API

Задача слоя - определить методы работы с внешними API. Без преобразования данных. Что приняли, то и отдали

Например: Есть API, у которого есть endpoint `/api/track/${id}`. Для работы с этим endpoint'ом в этом слое мы создаем метод, который как параметр принимает `id`, внутри себя делает запрос на `/api/track/${id}` и возвращает полученный ответ. Формат ответа так же прописывается в файл `types`, чтобы другие части приложения знали с какими данными работать

Структура:
```
api/
├── exampleApi1/       # Папка с методами для работы с определенным API
│   ├── index.ts       # Определение методов и экспорт типов во вне
│   └── types.ts       # Определение типов данных возвращаемых методами
└── ...
```

### Storage

Задача слоя - определить методы работы с внутренними базами данных. Включая инициализацию, получения, запись, и другие методы. Без преобразования данных. Что приняли, то и отдали

Структура:
```
storage/
├── exampleStorage1/   # Папка с методами для работы с определенным Storage
│   ├── index.ts       # Определение методов и экспорт типов во вне
│   └── types.ts       # Определение типов данных возвращаемых методами
└── ...
```

### Services

Задача слоя - определить методы работы с данными поступающими из различных источников для работы в приложении

Например:
1. В нашем приложении есть свой формат данных для работы с сущностями Track и Playlist. В этом слое мы можем описать, как полученные данные из API преобразуются в наш формат
2. Во внешнем API нет ручки получения списка полностью - только частями. В этом слое можно описать метод, который используя API будет получать все данные через несколько запросов

Чтобы приложения было проще тестировать, в папке также создается `mock` файл, содержащий функции заглушки. Продовый сервис ходит за данными в какие-то источники. Mock сервис не зависит от внешних источников, потому может использоваться для тестов

Структура:
```
services/
├──exampleService1/        # Папка с сервисом
│   ├── index.tsx          # Инициализация service в зависимости от окружения
│   ├── service.tsx        # Service для тестирования, где все методы - заглушки, возвращающие тестовые данные
│   ├── service.mock.tsx   # Основной файл сервиса, где описана вся логика
│   └── types.tsx          # Интерфейс сервиса, а так же те типы, которые описывает сам сервис, если это требуется
└── ...
```

### Configs

Задача слоя - хранить неизменяемые константы для других слоев. Хранятся только значения, без каких либо функций их получения 

## Shared - Общие файлы

По большей части содержат общие файлы/функции, которые могут потребоваться во всех слоях приложения. Файлы находящиеся здесь не должны импортировать что либо из других слоев

### Components

Содержит общие переиспользуемые компоненты

В папке `UI` хранятся компоненты из библиотеки компонентов `shadcn`

### Utils

Содержат общие функции или еще их можно назвать хелперами(helpers). Поделены на разные файлы по принципу - к какой части функциональности приложения их можно отнести

## Layout - Файлы отображения каркаса приложения

Хранить расстановку компонентов в одном файле - не удобно. Он сильно вырастает в размерах и его становится сложно читать. Поэтому основные части, которые содержат свой изолированный набор/компоновку компонентов выносятся в отдельные компоненты в `layout` слой

## Pages - Файлы отображения страниц(маршрутов) приложения

У каждого маршрута есть своя уникальная страница, на которой может быть свой набор компонентов со своим набором активной логики. Описание таких страниц хранится в слое `pages`, а подключается в файле настройки маршрутов `Routes.ts`. Создавать индексный файл для страниц не нужно, так как у них не подразумевается вложенности(это файлы должны определять только состав отображаемых компонентов без сложных вложенных структур). Так же не нужно для них создавать `stories`